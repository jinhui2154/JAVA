# JAVA基础(JAVA SE)

| 数据类型 | 明细                         | 默认值 |
| -------- | ---------------------------- | ------ |
| 基本类型 | byte、short、char、int、long | 0      |
|          | float、double                | 0.0    |
|          | boolean                      | false  |
| 引用类型 | 类、接口、数组、String       | null   |

​		JAVA栈：只保存基本数据类型和对象的引用

​		JAVA堆：当java创建一个类的对象或者数组时，都在堆中为新对象分配内存

​		方法区：方法

​		所有进程共享一个方法区所以是线程安全的

* **栈存放基本数据类型和对象的引用、堆存放对象和数组的实体**

注意：虽然栈存放的基本数据类型，但不是所有基本数据类型都存放在栈中，他们不是包含与被包含的关系

> 只有局部变量存放在栈中，当方法结束的时候就被释放
>
> 在类中声明的变量，也就是类的成员变量是存放在堆中

## API

### Object类

* 一个类要么默认继承了 Object 类，要么间接继承了 Object 类，Object 类是 JAVA 中的祖宗类

| 方法名                          | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| public String toString()        | 默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址  |
| public Boolean equals(Object o) | 默认是比较当前对象与另一个对象的地址是否相同，相同返回 true,不同返回 false |

### Objects类

| 方法名                                   | 说明                                        |
| ---------------------------------------- | ------------------------------------------- |
| public Boolean equals(Object a,Object b) | return (a==b)\|\|(a != null && a.equals(b)) |

### StringBuilder

* StringBuilder 是一个可变的字符串类、我们可以把它看成是一个对象容器

* 作用：提高字符串的操作效率，如拼接、修改等。**相比 String + 多次构造对象、StringBuilder.append 仅构造对象一次**


### String

* 双引号创建的字符串对象，在字符串常量池中存储同一个
* 通过 new 构造器创建的字符串对象，在堆内存中分开存储
* == 比对地址、equals 对比字符串内容

### Arrays类

* 数组操作工具类、专门用于操作数组元素的。

### Collection集合的体系特点

集合和数组都是容器

* 集合是 JAVA 中存储对象数据的一种容器
* 集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。
* 集合非常适合做元素的增删操作

#### Collection

* Collection 单列集合，每个元素(数据)只包含一个值

![Collection](https://cdn.jsdelivr.net/gh/jinhui2154/imgbed/2022/collection.png)

* 集合都是支持泛型的，可以在编译阶段约束集合只能操作某种数据类型

``` java
Collection<String> lists = new ArrayList<String>();
Collection<String> lists = new ArrayList<>();	//JDK 1.7 开始后面的泛型类型申明可以省略不写
```

* 注意：集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象

##### 迭代器 Iterator

* next()
* hasNext()

##### 增强 for 循环

``` java
for(元素数据类型 变量名:数组或者Collection集合){
 	//在此处使用变量即可，该变量就是元素      
}
```

##### Lambda 表达式

``` java
lists.forEach(s -> {
    System.out.printfln(s);
});
```

##### List

* ArrayList 底层是基于数组实现的，根据查询元素快，增删相对慢
* LinkedList 底层基于双链表实现的，查询元素慢，增删首尾元素是非常快的

##### set

* HashSet 底层结构：哈希表(数组、链表、红黑树的结合体)
  * LinkedHashSet 每个元素又额外的多了一个双链表的机制记录存储的顺序
* TreeSet 集合底层基于红黑树的数据结构实现排序

#### Map

* Map 双列集合，每个元素包含两个值(键值对)

##### HashMap

* 元素按照键是无序、不重复、无索引、值不作要求(与Map体系一致)

###### LinkedHashMap

* 元素按照键是有序、不重复、无索引、值不作要求

##### TreeMap

* 元素按照键是排序、不重复、无索引的、值不作要求

### ArrayList(集合)

* 集合的大小不固定，启动后可以动态变化，类型也可以选择不固定
* 集合非常适合做元素个数不确定，且要进行增删操作的业务场景
* **注意：集合中只能存储引用类型，不支持基本数据类型[泛型]**

## 面向对象

* this 关键字是什么？

可以出现在 构造器、方法中

**代表当前对象的地址**

**可以用于指定访问当前对象的成员变量、成员方法**

* super 关键字是什么？

**代表父类的地址** 

### 代码块

* 代码块是类的五大成分之一(成员变量、构造器、方法、**代码块**、内部类)，定义在类中方法外
* 在 Java 类下，使用 ｛｝括起来的代码被称为代码块

#### 静态代码块

​	 	需要通过 static 关键字修饰、随着类的加载而加载，并且自动触发，只执行一次

### 封装

封装的原则：对象代表什么，就得封装对应的数据，并提供数据对应的行为。

* 一般建议对成员变量使用 private (私有、隐藏)关键字修饰
* 为每个成员变量提供配套 public 修饰的 getter、setter 方法暴露其取值和赋值

#### JavaBean

也可以称为实体类，其对象可以用于在程序中封装数据

标准 JavaBean 须满足如下书写要求：

* 成员变量使用 private 修饰
* 提供成员变量对应的 setXxx() / getXxx() 方法
* 必须提供一个 无参构造器；有参数构造器是可写可不写的

#### static

##### 修饰变量

* static 修饰成员变量表示该成员变量只在内存中存储一份，可以被共享访问、修改

##### 修饰函数

* 如果该方法是以执行一个公用功能为目的，则可以申明成静态方法

1. 静态方法只能访问静态的成员，不可以直接访问实例成员
2. 实例方法可以访问静态的成员，也可以访问实例成员
3. 静态方法中是不可以出现 this 关键字的

##### 单例模式

###### 饿汉模式

* 在用类获取对象的时候，对象已经提前为你创建好了。

**设计步骤**

* 定义一个类，把构造器私有
* 定义一个静态变量存储一个对象

###### 懒汉模式

* 在真正需要该对象的时候，才去创建一个对象（延迟加载对象）

**设计模式**

* 定义一个类，把构造器私有
* 定义一个静态变量存储一个对象（私有：防止获取为空）
* 提供一个返回单例对象的方法（判别是否为空、且只初始化一次）

### 继承 extends

* 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器
* JAVA 中所有的类都是 Object 类的子类

#### 方法重写

* 重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致
* 私有方法不能被重写
* 子类重写父类方法时，子类方法的访问权限必须大于或者等于父类

* 子类不能重写父类的静态方法，如果重写会报错的

#### 抽象类

* 得到了抽象方法、失去了创建对象的能力
* 与 final 互斥

##### 模版方法模式

#### 接口

* JDK8 之前的接口中只能是抽象方法和常量，没有其他成分了
* 接口：体现了一种规范，常量 + 抽象方法
* 注意：由于接口体现规范思想，规范默认都是公开的，所以代码层面的 public static final、public abstract 可以省略不写
* 通过接口可以实现**多实现**、**多继承**
* 允许接口中直接定义带有方法体的方法 
  * 1.默认方法：必须用 default 修饰、默认用 public 修饰  
  * 2.静态方法：必须用 static 修饰(仅可通过接口名调用)、默认用 public 修饰    
  * 3.私有方法


#### 包

* 包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护
* 建包的语法格式：package 公司域名倒写.技术名称。包名建议全部英文小写，且具备意义。
* import 包名.类名; 不同包下的类必须导包才可以使用。
* 如果这个类中使用不同包下的相同的类名，此时默认只能导入一个类的包，另一个类要使用全名访问。

![java-power](https://cdn.jsdelivr.net/gh/jinhui2154/imgbed/2022/java-power.webp)

### 多态

多态的常见形式：

``` c++
父类类型 对象名称 = new 子类构造器;
接口 对象名称 = new 实现类构造器;
```

多态中成员访问特点：

``` java
方法调用：编译看左边（父类）、运行看右边（子类）
变量调用：编译看左边、运行也看左边（父类）
（多态侧重行为多态）    
```

优势：

* 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。

```java
Animal a = ** new Dog(); **
a.run();//后续业务行为随对象而变、后续代码无需改变
```

* 定义方法的时候，使用父类型作为参数，该方法就可以接收这父类的一切子类对象，体现出多态的扩展性与便利

**多态下会产生的一个问题：**

* 多态下不能使用子类的独有功能

**引用类型的数据转换：**

* 自动类型转换（从子到父）：子类对象赋值给父类类型的变量指向
* 强制类型转换（从父到子）：
  * 此时必须进行强制类型转换： 子类 对象变量 = （子类）父类类型的变量
  * 作用：可以解决多态下的劣势，可以实现调用子类独有的功能

### 包装类

* 其实就是 8 种基本数据类型对应的引用类型

| 基本数据类型 | 引用数据类型 |
| ------------ | ------------ |
| byte         | Byte         |
| short        | Short        |
| int          | Integer      |
| long         | Long         |
| char         | Character    |
| float        | Float        |
| double       | Double       |
| boolean      | Boolean      |

**为什么提供包装类？**

* JAVA 为了实现一切皆对象、为 8 种基本类型提供了对应的引用类型
* 后面的集合和泛型其实也只能支持包装类型，不支持基本数据类型

#### 包装类的特有功能

* 包装类的变量的默认值可以是 null , 容错率更高
* 可以把基本类型的数据转换成字符串类型(用处不大)

``` java
1. 调用 toString() 方法得到字符串结果
2. 调用 Integer.toString(基本数据类型)    
```

* 可以把字符串类型的数值转换成真实的数据类型(真的很有用)

``` java
1. Integer.parseInt("字符串类型的整数")
2. Double.parseDouble("字符串类型的小数")    
```

## Lambda表达式

* 作用：简化匿名内部类的代码写法

``` java
//Lambda 表达式的简化格式
(匿名内部类被重写方法的形参列表)->{
    被重写方法的方法体代码
}
注：-> 是语法形式，无实际含义
```

* 注意：Lambda 表达式只能简化函数式接口的匿名内部类的写法形式

### 什么是函数式接口？

* 首先必须是接口、其次接口中有且仅有一个抽象方法的形式
* 通常我们会在接口上加上一个 @FunctionalInterface 注解，标记该接口必须是满足函数式接口

 ### Lambda 表达式的省略写法(进一步在Lambda表达式的基础上继续简化)

* 参数类型可以省略不写
* 如果只有一个参数，参数类型可以省略，同时()也可以省略
* 如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写，同时要省略分号！
* 如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写。此时，如果这行代码是 return 语句，必须省略 return 不写，同时也必须省略";"不写

## 异常

* 异常是程序在“编译”或者“执行”的过程中可能出现的问题。**注意：语法错误不算在异常体系中。**

* 比如：数组索引越界、空指针异常、日期格式化异常，等...

### 为什么要学习异常

* 异常一旦出现了，如果没有提前处理，程序就会退出 JVM 虚拟机而终止

* 研究异常并且避免异常，然后提前处理异常，体现的是程序的安全、健壮性

### Error 

* 系统级别问题、JVM 退出等，代码无法控制

### Exception

* java.lang 包下，称为异常类，它表示程序本身可以处理的问题
* RuntimeException及其子类: 运行时异常、编译阶段不会报错。(空指针异常、数组索引越界异常)
  * 数组索引越界异常：ArrayIndexOutOfBoundsException
  * 空指针异常：NullPointerException ,直接输出没有问题，但是调用空指针的变量功能就会报错
  * 数学操作异常：ArithmeticException
  * 类型转换异常：ClassCastException
  * 数字转换异常：NumberFormatException

* 除 RuntimeException 之外所有的异常：编译时异常，编译期必须处理的，否则程序不能通过编译。(日期格式化异常)

### 异常的默认处理流程

1. 默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticeException
2. 异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给 JVM 虚拟机
3. 虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据
4. 直接从当前执行的异常点干掉当前程序
5. 后续代码没有机会执行了，因为程序已经死亡

#### 编译时异常的处理机制

* 出现异常直接抛出去给调用者，调用者也继续抛出去[程序依旧崩溃] throws
* 出现异常自己捕获处理，不麻烦别人  try ... catch ...
* 前两者结合，出现异常直接抛出去给调用者，调用者捕获处理 

#### 运行时异常的处理机制















